package com.springbootpostresql.SpringBootPostgreSQL.student;

import jakarta.persistence.*;

import java.time.LocalDate;
import java.time.Period;

@Entity//This one is for the Hibernate
@Table
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String name;
    private String email;
    private LocalDate dob;
    @Transient //Basically this say that there is no need for age to be a column in our DB,
    // which means that age will be calculated first
    private Integer age;


    //NoArgsConstructor
    public Student() {
    }

    //AllArgsConstructor
    public Student(long id,
                   String name,
                   String email,
                   LocalDate dob) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.dob = dob;
    }

    //Constructor without ID (ID is auto generated by the DB)
    public Student(String name,
                   String email,
                   LocalDate dob) {
        this.name = name;
        this.email = email;
        this.dob = dob;
    }

    //Implement the Getter and Setters
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public LocalDate getDob() {
        return dob;
    }

    public void setDob(LocalDate dob) {
        this.dob = dob;
    }

    //This is where add the calculation part for the age
    public Integer getAge() {
        return Period.between(this.dob, LocalDate.now()).getYears();
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", dob=" + dob +
                ", age=" + age +
                '}';
    }
}//End of Student Class



//NOTES:

/*
The `toString()` method is a method provided by the `Object` class in Java, and it is meant to return a string representation of an object. When you override the `toString()` method in your class, you can define how you want the object to be represented as a string.

In the code snippet you provided, the `toString()` method is overridden in the `Student` class. It returns a string representation of a `Student` object with its attributes, such as `id`, `name`, `email`, `dob`, and `age`. By providing this implementation, you can conveniently obtain a meaningful string representation of a `Student` object.

The `toString()` method is commonly used for debugging and logging purposes. It allows you to quickly inspect the values of an object's attributes without explicitly accessing each attribute individually. For example, you can use it to print the details of a `Student` object to the console, log it to a file, or display it in a user interface.

By having a well-defined `toString()` method, you can improve the readability and usability of your code, especially when working with complex objects or debugging scenarios. Additionally, it's often recommended to override `toString()` when implementing your own classes to provide a human-readable and meaningful representation of the object's state.
==========================================================================

(Q)Use of this ;  @GeneratedValue(strategy = GenerationType.IDENTITY)

The @GeneratedValue annotation is used in JPA (Java Persistence API) to specify the generation strategy for automatically generating unique identifier values for entity objects.

In particular, the @GeneratedValue annotation is often used in combination with the @Id annotation to define the primary key field of an entity class.

The strategy attribute of the @GeneratedValue annotation specifies the strategy to be used for generating the identifier values. The GenerationType.IDENTITY strategy indicates that the database will automatically assign a unique identifier value when a new entity object is persisted.

Here's an example of how @GeneratedValue can be used:

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;


In this example, the id field is marked as the primary key of the entity class. The @GeneratedValue annotation with GenerationType.IDENTITY indicates that the database will generate the unique identifier values for this field using an identity column.

By using this annotation, you delegate the responsibility of generating unique identifier values to the database, which can be useful in scenarios where you have an auto-incrementing primary key column in the database.

=================================================================================


(Q)is import jakarta.persistence.*; and import javax.persistence.*; the same?


No, import jakarta.persistence.*; and import javax.persistence.*; are not the same.

Prior to Jakarta EE 9, the Java Persistence API (JPA) was part of the Java EE (Enterprise Edition) platform, and the package for JPA classes was javax.persistence. However, starting from Jakarta EE 9, the Java EE technologies were migrated to the Eclipse Foundation and rebranded as Jakarta EE.

As a result, the package name for JPA classes has also changed to jakarta.persistence. Therefore, if you are using a Jakarta EE 9 or newer version, you should use import jakarta.persistence.*; to import the JPA classes.

However, if you are using an older version of Java EE or JPA, you should continue using import javax.persistence.*; to import the JPA classes.

It's important to note that the functionality and usage of JPA remain the same regardless of the package name. The package change is primarily due to the transition from Java EE to Jakarta EE.

==========================================================================
(Q)use of @Transient

The `@Transient` annotation is used in Java Persistence API (JPA) to mark a field or property of an entity class that should not be persisted to the database.

When an entity class is mapped to a database table, by default, all non-transient fields or properties are persisted to the corresponding columns in the table. However, there may be cases where you have certain fields that should not be stored in the database. In such cases, you can annotate those fields with `@Transient`.

The use of `@Transient` has the following implications:

1. Persistence: Fields marked with `@Transient` are not considered for database persistence. They are ignored during the persistence process, and their values are not stored in the database.

2. Serialization: Fields marked with `@Transient` are also ignored during object serialization. When an object is serialized, the `@Transient` fields are not included in the serialized form.

3. Reflection-based operations: `@Transient` fields are also ignored during reflection-based operations, such as field access or mapping.

Typically, `@Transient` is used for fields that are derived from other fields, calculated at runtime, or have temporary or transient values that don't need to be stored in the database.

Here's an example usage of `@Transient`:


@Entity
public class Product {
    @Id
    private Long id;

    private String name;

    @Transient
    private double calculatedPrice;

    // Constructors, getters, setters, etc.
}
```

In the above example, the `calculatedPrice` field is marked with `@Transient`, indicating that it should not be persisted to the database.

 */
